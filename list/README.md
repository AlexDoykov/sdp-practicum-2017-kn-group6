### Задачи

1. Имплементирайте абстрактния тип от данни линеен едносвързан списък (`LinkedList`). Използвайте дадения шаблонен интерфейс (абстрактен клас) `List`.
2. Написани са някои тестове, които можете да използвате за проверка. Напишете още тестове. Опитайте се да счупите списъка, който сте изпрограмирали.

Имплементирайте **библиотека** от функции за работа със списъци:

**Disclaimer! Можете да не ползвате шаблони, ако ви е твърде трудно** :smile:

1. Реализирайте шаблонна функция `int count<T>(Node<T>* head, T x)`,
която преброява колко пъти елементът `x` се среща в списъка с глава `head`.

2. Реализирайте функция `Node<int>* range(int a, int b)`, където `a <= b`.
Функцията създава списък с целите числа от затворения интервал `[a, a + 1, ..., b]`
и връща главата на този списък.

3. Реализирайте шаблонна функция `void removeAll<T>(Node<T>* head, T x)`,
която изтрива всички срещания на елемент `x` в списъка с глава `head`.

4. Реализирайте шаблонна функция `void append<T>(Node<T>* head1, Node<T>* head2)`,
която добавя към края на списъка с глава `head1` всички елементи на списъка с глава `head2`.

5. Реализирайте шаблонна функция `Node<T>* concat<T>(Node<T>* head1, Node<T>* head2)`,
която конкатенира два списъка с глави `head1` и `head2` в трети списък и връща указател към неговата глава.

6. Реализирайте функция `Node<int>* map(Node<int>* head, int (*fn)(int))`,
която приема главата `head` на списък с цели числа и връща главата на нов списък,
който е копие на подадения списък, но върху всеки елемент е приложена целочислената функция `fn`.

7. Реализирайте шаблонна функция `void reverse<T>(Node<T>* head)`,
която обръща реда на елементите в списъка с глава `head`. Например, списъкът с елементи 1, 2, 3
ще се преобразува до списъкът с елементи 3, 2, 1.

8. Да се напише шаблонна функция `bool duplicates(Node<T>* head)`, която проверява
дали в подадения списък има дублиращи/повтарящи се елементи.

9. Да се напише шаблонна функция `bool removeDuplicates(Node<T>* head)`, която премахва всички
дублиращи/повтарящи се елементи в подадения списък.

10. Да се напише шаблонна функция `bool isSorted(Node<T>* head)`, която проверява дали
подаденият списък е сортиран.

11. Да се напише шаблонна функция `bool palindrome(Node<T>* head)`, която проверява дали
елементите на подадения списък образуват палиндром.
Тоест да се провери дали списъкът се чете еднакво, както отляво надясно, така и отдясно наляво.

12. Да се напише шаблонна функция `Node<T>* sortedMerge(Node<Node<T>>* listHeads)`,
която приема главата на списък, който има глави на **сортирани** списъци.
Функцията връща главата на нов **сортиран** списък с всички елемнти на всички подадени сортирани списъци.
